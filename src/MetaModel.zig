//! Metamodel schema
//! Autogenerated by JSON Schema -> Zig tooling, slightly modified

const std = @import("std");
const tres = @import("tres");
const Undefinedable = tres.Undefinedable;

enumerations: []Enumeration,
notifications: []Notification,
requests: []Request,
structures: []Structure,
typeAliases: []TypeAlias,

pub const MessageDirection = enum {
    clientToServer,
    serverToClient,
    both,

    pub fn format(value: MessageDirection, comptime fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void {
        _ = fmt;
        _ = options;

        switch (value) {
            .clientToServer => try writer.writeAll("client_to_server"),
            .serverToClient => try writer.writeAll("server_to_client"),
            .both => try writer.writeAll("bidirectional"),
        }
    }
};

pub const AndType = struct {
    comptime kind: []const u8 = "and",

    items: []Type,
};

pub const ArrayType = struct {
    comptime kind: []const u8 = "array",

    element: *Type,
};

pub const BaseType = struct {
    comptime kind: []const u8 = "base",

    name: BaseTypeName,
};

pub const BaseTypeName = enum {
    URI,
    DocumentUri,
    integer,
    uinteger,
    decimal,
    RegExp,
    string,
    boolean,
    null,
};

pub const BooleanLiteralType = struct {
    comptime kind: []const u8 = "booleanLiteral",

    value: bool,
};

pub const Enumeration = struct {
    documentation: Undefinedable([]const u8),
    name: []const u8,
    proposed: Undefinedable(bool),
    since: Undefinedable([]const u8),
    supportsCustomValues: Undefinedable(bool),
    type: EnumerationType,
    values: []EnumerationEntry,
};

pub const EnumerationEntry = struct {
    documentation: Undefinedable([]const u8),
    name: []const u8,
    proposed: Undefinedable(bool),
    since: Undefinedable([]const u8),
    value: union(enum) {
        number: f64,
        string: []const u8,
    },
};

pub const EnumerationType = struct {
    comptime kind: []const u8 = "base",

    name: enum {
        string,
        integer,
        uinteger,
    },
};

pub const IntegerLiteralType = struct {
    comptime kind: []const u8 = "integerLiteral",

    value: f64,
};

pub const MapKeyType = union(enum) {
    base: struct {
        comptime kind: []const u8 = "base",

        name: enum {
            Uri,
            DocumentUri,
            string,
            integer,
        },
    },
    ReferenceType: ReferenceType,
};

pub const MapType = struct {
    comptime kind: []const u8 = "map",

    key: MapKeyType,
    value: *Type,
};

pub const Notification = struct {
    documentation: Undefinedable([]const u8),
    messageDirection: MessageDirection,
    method: []const u8,
    params: Undefinedable(union(enum) {
        Type: Type,
        array_of_Type: []Type,
    }),
    proposed: Undefinedable(bool),
    registrationMethod: Undefinedable([]const u8),
    registrationOptions: Undefinedable(Type),
    since: Undefinedable([]const u8),
};

pub const OrType = struct {
    comptime kind: []const u8 = "or",

    items: []Type,
};

pub const Property = struct {
    documentation: Undefinedable([]const u8),
    name: []const u8,
    optional: Undefinedable(bool),
    proposed: Undefinedable(bool),
    since: Undefinedable([]const u8),
    type: Type,
};

pub const ReferenceType = struct {
    comptime kind: []const u8 = "reference",

    name: []const u8,
};

pub const Request = struct {
    documentation: Undefinedable([]const u8),
    messageDirection: MessageDirection,
    errorData: Undefinedable(Type),
    method: []const u8,
    params: Undefinedable(union(enum) {
        Type: Type,
        array_of_Type: []Type,
    }),
    partialResult: Undefinedable(Type),
    proposed: Undefinedable(bool),
    registrationMethod: Undefinedable([]const u8),
    registrationOptions: Undefinedable(Type),
    result: Type,
    since: Undefinedable([]const u8),
};

pub const StringLiteralType = struct {
    comptime kind: []const u8 = "stringLiteral",

    value: []const u8,
};

pub const Structure = struct {
    documentation: Undefinedable([]const u8),
    extends: Undefinedable([]Type),
    mixins: Undefinedable([]Type),
    name: []const u8,
    properties: []Property,
    proposed: Undefinedable(bool),
    since: Undefinedable([]const u8),
};

pub const StructureLiteral = struct {
    documentation: Undefinedable([]const u8),
    properties: []Property,
    proposed: Undefinedable(bool),
    since: Undefinedable([]const u8),
};

pub const StructureLiteralType = struct {
    comptime kind: []const u8 = "literal",

    value: StructureLiteral,
};

pub const TupleType = struct {
    comptime kind: []const u8 = "tuple",

    items: []Type,
};

pub const Type = union(enum) {
    BaseType: BaseType,
    ReferenceType: ReferenceType,
    ArrayType: ArrayType,
    MapType: MapType,
    AndType: AndType,
    OrType: OrType,
    TupleType: TupleType,
    StructureLiteralType: StructureLiteralType,
    StringLiteralType: StringLiteralType,
    IntegerLiteralType: IntegerLiteralType,
    BooleanLiteralType: BooleanLiteralType,
};

pub const TypeAlias = struct {
    documentation: Undefinedable([]const u8),
    name: []const u8,
    proposed: Undefinedable(bool),
    since: Undefinedable([]const u8),
    type: Type,
};

pub const TypeKind = enum {
    base,
    reference,
    array,
    map,
    @"and",
    @"or",
    tuple,
    literal,
    stringLiteral,
    integerLiteral,
    booleanLiteral,
};
